# -*- coding: utf-8 -*-
"""Miniproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16LXuH4FR3uB8sOEOenIKvpzeQhe50TFy
"""



import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats

from sklearn.preprocessing import StandardScaler, PolynomialFeatures, OneHotEncoder,StandardScaler,PowerTransformer, MinMaxScaler, RobustScaler
from sklearn.model_selection import KFold, cross_val_predict, train_test_split,GridSearchCV,cross_val_score, cross_validate
from sklearn.linear_model import LinearRegression, Lasso, Ridge,ElasticNet
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import r2_score,mean_squared_error
from sklearn.metrics import classification_report, confusion_matrix, log_loss, recall_score
from sklearn.pipeline import make_pipeline
from sklearn.compose import make_column_transformer
from sklearn.neighbors import KNeighborsRegressor
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVR
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestRegressor,GradientBoostingRegressor, ExtraTreesRegressor
from sklearn.feature_selection import SelectKBest,SelectPercentile,f_classif,f_regression,mutual_info_regression
from xgboost import XGBRegressor
from xgboost import plot_importance
from sklearn.impute import SimpleImputer
from yellowbrick.classifier import ConfusionMatrix
from yellowbrick.cluster import KElbowVisualizer

import missingno as msno

#importing plotly and cufflinks in offline mode
import cufflinks as cf
import plotly.offline
cf.go_offline()
cf.set_config_file(offline=False, world_readable=True)

import warnings
warnings.filterwarnings('ignore')

plt.rcParams["figure.figsize"] = (10,6)
pd.set_option('max_colwidth',200)
pd.set_option('display.max_rows', 1000)
pd.set_option('display.max_columns', 200)
pd.set_option('display.float_format', lambda x: '%.7f' % x)

def missing (df):
    missing_number = df.isnull().sum().sort_values(ascending=False)
    missing_percent = (df.isnull().sum()/df.isnull().count()).sort_values(ascending=False)
    missing_values = pd.concat([missing_number, missing_percent], axis=1, keys=['Missing_Number', 'Missing_Percent'])
    return missing_values

def first_looking(col):
    print("column name    : ", col)
    print("--------------------------------")
    print("per_of_nulls   : ", "%", round(df[col].isnull().sum()/df.shape[0]*100, 2))
    print("num_of_nulls   : ", df[col].isnull().sum())
    print("num_of_uniques : ", df[col].nunique())
    print(df[col].value_counts(dropna = False))

df = pd.read_csv("dataset.csv")
dp=df

df.head(10)

"""Data Preparation

"""

df.columns = df.columns.str.lower().str.replace('&', '_').str.replace(' ', '_')
df.columns

df.shape

print(f'The dataset consists of {df.shape[0]} instances with {df.shape[1]-1} features and 1 target variable')

df.info()

df.describe(include=object)

df.duplicated().value_counts()

"""Data Cleaning"""

df.drop("id", axis=1, inplace=True )

df.columns

"""Double-click (or enter) to edit

#Examine corelation using Heatmap

Heatmap is defined as a graphical representation of data using colors to visualize the value of the matrix. In this, to represent more common values or higher activities brighter colors basically reddish colors are used and to represent less common or activity values, darker colors are preferred. Heatmap is also defined by the name of the shading matrix. Heatmaps in Seaborn can be plotted by using the seaborn.heatmap() function.

A correlation heatmap is a heatmap that shows a 2D correlation matrix between two discrete dimensions, using colored cells to represent data from usually a monochromatic scale. The values of the first dimension appear as the rows of the table while of the second dimension as a column.

"""

print(df.corr())
sns.heatmap(df.corr(), annot=True)

"""Splitting data into numerical and categorial

    select dtypes returns columns DataFrame.select_dtypes(include=None, exclude=None)

    Return a subset of the DataFrameâ€™s columns based on the column dtypes.

"""

numerical=df.drop(['stroke'], axis=1).select_dtypes('number').columns
categorical=df.select_dtypes('object').columns


print(f'Numerical Columns:  {df[numerical].columns}')
print('\n')
print(f'Categorical Columns: {df[categorical].columns}')

"""Examination of target variable"""

first_looking('stroke')

"""4.Demonstrate how to handle missing data"""

print(df.isna().sum())

import seaborn as sns
import matplotlib.pyplot as plt


plt.title('Missing Value Status',fontweight='bold')
ax = sns.heatmap(df.isna().sum().to_frame(),annot=True,fmt='d',cmap='vlag')
ax.set_xlabel('Amount Missing')
plt.show()

df['bmi'].fillna(df['bmi'].mean(),inplace=True)
df['smoking_status'].fillna(df['smoking_status'].mean(),inplace=True)
print(df.isna().sum())

"""Label encoder"""

from sklearn import preprocessing
#creating labelEncoder
le = preprocessing.LabelEncoder()
df['ever_married']=le.fit_transform(df['ever_married'])
df['residence_type']=le.fit_transform(df['residence_type'])
df['gender']=le.fit_transform(df['gender'])
df['work_type']=le.fit_transform(df['work_type'])
df['smoking_status']=le.fit_transform(df['smoking_status'])
print(df)

"""X and Y Splitting"""

x = df.iloc[:,0:-1].values
y = df.iloc[:,-1].values

print('X Shape', x.shape)
print('Y Shape',y.shape)

print(x)

from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
ct = ColumnTransformer(transformers=[('encoder',OneHotEncoder(),[0,5,9])],remainder='passthrough')
x = np.array(ct.fit_transform(x))

https://ijesc.org/upload/994c14344f630b9dcf09e579cb92a028.Stroke%20Predictions%20using%20Healthcare%20Dataset.pdf

